#include <common/random.hsh>

#define SIDE_TO_SIDE_FREQ1 1.975
#define SIDE_TO_SIDE_FREQ2 0.793
#define UP_AND_DOWN_FREQ1 0.375
#define UP_AND_DOWN_FREQ2 0.193

vec4 SmoothCurve( vec4 x ) {   return x * x *( 3.0 - 2.0 * x ); } 
vec4 TriangleWave( vec4 x ) {   return abs( fract( x + 0.5 ) * 2.0 - 1.0 ); } 
vec4 SmoothTriangleWave( vec4 x ) {   return SmoothCurve( TriangleWave( x ) ); }

vec3 WindAnimation(sampler2D noiseTexture, vec2 windDir,
    vec3 position, float bendFactor, float animTime, vec3 location) {

    vec3 originalPos = position;

    float centerDistance = length(position.xz);
    float height = position.y * bendFactor * 0.5;

    float bendScale = textureLod(noiseTexture, location.xz / 128.0 + windDir * 0.01 * animTime, 0.0).r * 0.1;
    float mainBending = height * bendScale;
    mainBending += 1.0;
    mainBending *= mainBending;
    mainBending = mainBending * mainBending - mainBending;

    position.xz += windDir * mainBending;
    position.xyz = normalize(position) * length(originalPos);

    float branchAmp = .1;
    float detailAmp = 0.02;
    float edgeAtten = 0.5;
    float speed = 0.2;
    float detailPhase = 0.5; // Should be controlled by vertex colors
    float objectPhase = dot(location, vec3(1.0));
    float vertexPhase = dot(originalPos, vec3(detailPhase + objectPhase));
    vec2 wavesIn = (animTime * 3.0) + vec2(vertexPhase, objectPhase);
    vec4 waves = (fract(wavesIn.xxyy * 
        vec4(SIDE_TO_SIDE_FREQ1, SIDE_TO_SIDE_FREQ2, UP_AND_DOWN_FREQ1, UP_AND_DOWN_FREQ2)) * 
        2.0 - 1.0) * speed;
    waves = SmoothTriangleWave(waves);
    
    vec2 waveSum = waves.xy + waves.zw;
    
    //position.xyz += waveSum.x * vec3(edgeAtten * detailAmp * vec3(0.0, 1.0,0.0));
    //position.y += waveSum.y * centerDistance * branchAmp;
    
    //position.y += sin(animTime* 10.0) * pow(centerDistance/6.0, 4.0);

    return position;

}