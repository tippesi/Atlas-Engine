#include <terrainMaterial.hsh>
#include <../globals.hsh>

#ifndef DISTANCE
layout(quads, equal_spacing, cw) in;
#else
layout(quads, equal_spacing, cw) in;
#endif

layout (set = 3, binding = 1) uniform sampler2D normalMap;
layout (set = 3, binding = 2) uniform usampler2D splatMap;
layout(set = 3, binding = 7) uniform sampler2DArray displacementMaps;

layout (set = 3, binding = 8, std140) uniform UBO {
    TerrainMaterial materials[128];
} Materials;

layout (set = 3, binding = 9, std140) uniform UniformBuffer {
    vec4 frustumPlanes[6];

    float heightScale;
    float displacementDistance;

    float tessellationFactor;
    float tessellationSlope;
    float tessellationShift;
    float maxTessellationLevel;
} Uniforms;

layout(push_constant) uniform constants {
    float nodeSideLength;
    float tileScale;
    float patchSize;
    float normalTexelSize;

    float leftLoD;
    float topLoD;
    float rightLoD;
    float bottomLoD;

    vec2 nodeLocation;
} PushConstants;

// layout(location=0) flat in uvec4 materialIndicesTC[];

layout(location=0) out vec2 materialTexCoords;
layout(location=1) out vec2 texCoords;
layout(location=2) out vec3 ndcCurrent;
layout(location=3) out vec3 ndcLast;
//layout(location=4) flat out uvec4 materialIndicesTE;

float SampleDisplacement(vec2 off, uvec4 indices) {

	if (indices.x == indices.y && 
		indices.x == indices.z &&
		indices.x == indices.w)
		return texture(displacementMaps, vec3(materialTexCoords / 4.0, float(indices.x))).r;
	
	float q00 = texture(displacementMaps, vec3(materialTexCoords / 4.0, float(indices.x))).r;
	float q10 = texture(displacementMaps, vec3(materialTexCoords / 4.0, float(indices.y))).r;
	float q01 = texture(displacementMaps, vec3(materialTexCoords / 4.0, float(indices.z))).r;
	float q11 = texture(displacementMaps, vec3(materialTexCoords / 4.0, float(indices.w))).r;
	
	// Interpolate samples horizontally
	float h0 = mix(q00, q10, off.x);
	float h1 = mix(q01, q11, off.x);
	
	// Interpolate samples vertically
	return mix(h0, h1, off.y);	
	
}

float Interpolate(float q00, float q10, float q01, float q11, vec2 off) {

	// Interpolate samples horizontally
	float h0 = mix(q00, q10, off.x);
	float h1 = mix(q01, q11, off.x);
	
	// Interpolate samples vertically
	return mix(h0, h1, off.y);	

}

void main(){

    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;
	
	// world position
	vec4 position =
	((1.0 - u) * (1.0 - v) * gl_in[3].gl_Position +
	u * (1.0 - v) * gl_in[0].gl_Position +
	u * v * gl_in[1].gl_Position +
	(1.0 - u) * v * gl_in[2].gl_Position);
	
	texCoords = vec2(position.x, position.z) - PushConstants.nodeLocation;

	materialTexCoords = texCoords;
	
	texCoords /= PushConstants.nodeSideLength;
	
	//materialIndicesTE = materialIndicesTC[0];
	
#ifndef DISTANCE
	float vertexDistance = distance(position.xyz, globalData.cameraLocation.xyz);
	float weight = clamp((Uniforms.displacementDistance - vertexDistance), 0.0, 1.0);

	vec2 tex = vec2(PushConstants.normalTexelSize) + texCoords *
        (1.0 - 3.0 * PushConstants.normalTexelSize)
		+ 0.5 * PushConstants.normalTexelSize;
	vec3 norm = 2.0 * texture(normalMap, tex).rgb - 1.0;
	
	uvec4 indices;
	float texel = 1.0 / (8.0 * PushConstants.patchSize);
	tex = floor(texCoords / texel) * texel;
	indices.x = texture(splatMap, tex).r;
	indices.y = texture(splatMap, tex + vec2(texel, 0.0)).r;
	indices.z = texture(splatMap, tex + vec2(0.0, texel)).r;
	indices.w = texture(splatMap, tex + vec2(texel, texel)).r;

	if (weight > 0.0) {
		tex = materialTexCoords / PushConstants.tileScale;
		vec2 off = tex - floor(tex);
		float displacementScale = Interpolate(
			Materials.materials[indices.x].displacementScale,
            Materials.materials[indices.y].displacementScale,
            Materials.materials[indices.z].displacementScale,
            Materials.materials[indices.w].displacementScale,
			off
		);
		float displacement = SampleDisplacement(off, indices)
			* displacementScale * weight;
		
		position.xyz += norm * displacement;
	}
#endif
	
	gl_Position = globalData.pMatrix * globalData.vMatrix * position;
	
	ndcCurrent = vec3(gl_Position.xy, gl_Position.w);
	
	vec4 last = globalData.pvMatrixLast * position;
	ndcLast = vec3(last.xy, last.w);
	
}