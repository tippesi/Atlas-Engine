// Based on DDGI: 
// Majercik, Zander, et al. "Dynamic diffuse global illumination with ray-traced irradiance fields."
// Journal of Computer Graphics Techniques Vol 8.2 (2019).
// Majercik, Zander, et al. "Scaling Probe-Based Real-Time Dynamic Global Illumination for Production."
// arXiv preprint arXiv:2009.10796 (2020).

#include <../common/octahedron.hsh>
#include <../common/utility.hsh>
#include <../common/flatten.hsh>

#define PROBE_STATE_NEW 0
#define PROBE_STATE_ACTIVE 1
#define PROBE_STATE_INACTIVE 2
#define VOLUME_CASCADE_COUNT 8

layout(set = 2, binding = 24) uniform sampler2DArray irradianceVolume;
layout(set = 2, binding = 25) uniform sampler2DArray momentsVolume;

layout(std430, set = 2, binding = 19) buffer ProbeStates {
    vec4 probeStates[];
};

layout(std430, set = 2, binding = 20) buffer ProbeOffsets {
    vec4 probeOffsets[];
};

struct DDGICascade {
    vec4 volumeMin;
    vec4 volumeMax;
    vec4 cellSize;
    ivec4 offsetDifference;
};

layout(std140, set = 2, binding = 26) uniform DDGIBuffer {    
    DDGICascade cascades[VOLUME_CASCADE_COUNT];

    vec4 volumeCenter;
    ivec4 volumeProbeCount;
    int cascadeCount;

    float volumeBias;

    int volumeIrradianceRes;
    int volumeMomentsRes;

    uint rayCount;
    uint inactiveRayCount;

    float hysteresis;

    float volumeGamma;
    float volumeStrength;

    float depthSharpness;
    int optimizeProbes;

    int volumeEnabled;
} ddgiData;

struct RayHit {
    vec3 direction;
    vec3 radiance;
    float hitDistance;
};

struct PackedRayHit {
    vec4 data;
};

RayHit UnpackRayHit(PackedRayHit compressed) {
    RayHit hit;

    hit.direction.xy = unpackHalf2x16(floatBitsToUint(compressed.data.x));
    hit.radiance.xy = unpackHalf2x16(floatBitsToUint(compressed.data.y));
    vec2 comn = unpackHalf2x16(floatBitsToUint(compressed.data.z));

    hit.direction.z = comn.x;
    hit.radiance.z = comn.y;

    hit.hitDistance = compressed.data.w;

    return hit;
}

PackedRayHit PackRayHit(RayHit hit) {
    PackedRayHit compressed;

    // Maximum possible value for float16 is 65.5 * 10^4
    hit.radiance = min(hit.radiance, 3200.0);

    vec2 comn = vec2(hit.direction.z, hit.radiance.z);
    compressed.data.x = uintBitsToFloat(packHalf2x16(hit.direction.xy));
    compressed.data.y = uintBitsToFloat(packHalf2x16(hit.radiance.xy));
    compressed.data.z = uintBitsToFloat(packHalf2x16(comn));
    compressed.data.w = hit.hitDistance;

    return compressed;
}

uint GetProbeRayCount(uint state) {
    return state == PROBE_STATE_INACTIVE ? ddgiData.inactiveRayCount : ddgiData.rayCount;
}

vec3 GetProbePosition(ivec3 probeIdx, int cascadeIndex) {
    return ddgiData.cascades[cascadeIndex].volumeMin.xyz + vec3(probeIdx) * ddgiData.cascades[cascadeIndex].cellSize.xyz;
}

uint GetProbeState(uint idx) {
    return floatBitsToUint(probeStates[idx].x);
}

vec3 GetProbeOffset(uint idx) {
    return probeOffsets[idx].xyz;
}

/*
ivec3 GetNearestProbe(vec3 position) {
    vec3 localPosition = position - ddgiData.volumeMin.xyz;
    return ivec3(round(localPosition / ddgiData.cellSize.xyz));
}
*/

uint GetProbeIdx(ivec3 probe, int cascadeIndex) {
    return Flatten3D(probe.xzy, ddgiData.volumeProbeCount.xzy) + 
        uint(cascadeIndex * ddgiData.volumeProbeCount.w);
}

int GetProbeCascadeIndex(uint idx) {
    return int(idx) / ddgiData.volumeProbeCount.w;
}

int GetProbeCascadeIndex(ivec3 probe) {
    return probe.y / ddgiData.volumeProbeCount.y;
}

ivec3 GetProbeGridCoord(uint idx) {
    int index = int(idx) % ddgiData.volumeProbeCount.w;
    return Unflatten3D(index, ddgiData.volumeProbeCount.xzy).xzy;
}

bool IsInsideVolume(vec3 position) {
    // Cascade 0 has the same size as the whole volume
    return !any(lessThan(position, ddgiData.cascades[0].volumeMin.xyz))
        && !any(greaterThan(position, ddgiData.cascades[0].volumeMax.xyz));
}

bool IsInsideCascade(vec3 position, int cascadeIndex) {

    return !any(lessThan(position, ddgiData.cascades[cascadeIndex].volumeMin.xyz))
        && !any(greaterThan(position, ddgiData.cascades[cascadeIndex].volumeMax.xyz));

}

vec3 GetProbeCoord(ivec3 probeIndex, int cascadeIndex, vec2 octCoord, vec2 probeRes, vec2 texelSize, float volumeRes) {

    vec3 coord = vec3(probeRes * vec2(probeIndex.xz) + vec2(1.0), 
        float(probeIndex.y + cascadeIndex * ddgiData.volumeProbeCount.y));
    coord.xy *= texelSize;

    vec2 localCoord = octCoord * float(volumeRes) * texelSize;
    coord.xy += localCoord;

    return coord;

}

vec4 GetLocalIrradianceFromCascade(vec3 P, vec3 V, vec3 N, vec3 geometryNormal, int cascadeIndex) {

    float minAxialDistance = min3(ddgiData.cascades[cascadeIndex].cellSize.xyz);
    vec3 biasedP = P + (0.7 * geometryNormal - 0.3 * V) * 
        (0.75 * minAxialDistance) * ddgiData.volumeBias;

    vec2 irrRes = vec2(ddgiData.volumeIrradianceRes + 2);
    vec2 totalResolution = vec2(ddgiData.volumeProbeCount.xz) * irrRes;
    vec2 irrTexelSize = 1.0 / totalResolution;
    vec2 irrOctCoord = UnitVectorToOctahedron(N);

    vec2 momRes = vec2(ddgiData.volumeMomentsRes + 2);
    totalResolution = vec2(ddgiData.volumeProbeCount.xz) * momRes;
    vec2 momTexelSize = 1.0 / totalResolution;

    vec3 localPosition = biasedP - ddgiData.cascades[cascadeIndex].volumeMin.xyz;
    ivec3 baseCell = ivec3(localPosition / ddgiData.cascades[cascadeIndex].cellSize.xyz);

    float sumWeight = 0.0;
    vec3 sumIrradiance = vec3(0.0);

    float sumWeightCheb = 0.0;
    vec3 sumIrradianceCheb = vec3(0.0);

    vec3 alpha = localPosition / ddgiData.cascades[cascadeIndex].cellSize.xyz - vec3(baseCell);

    float totalVisibility = 0.0;

    for (int i = 0; i < 8; i++) {
        ivec3 offset = ivec3(i, i >> 1, i >> 2) & ivec3(1);
        ivec3 gridCell = clamp(baseCell + offset, ivec3(0), ddgiData.volumeProbeCount.xyz - ivec3(1));

        uint probeIdx = GetProbeIdx(gridCell, cascadeIndex);
        uint probeState = GetProbeState(probeIdx);
        if (probeState == PROBE_STATE_INACTIVE) continue;

        vec3 probeOffset = probeOffsets[probeIdx].xyz;
        vec3 probePos = vec3(gridCell) * ddgiData.cascades[cascadeIndex].cellSize.xyz +
            probeOffset + ddgiData.cascades[cascadeIndex].volumeMin.xyz;
        vec3 pointToProbe = probePos - P;
        vec3 L = normalize(pointToProbe);

        vec3 biasedProbeToPosition = biasedP - probePos;
        float biasedDistToProbe = length(biasedProbeToPosition);
        biasedProbeToPosition /= biasedDistToProbe;

        vec3 trilinear = mix(vec3(1.0) - alpha, alpha, vec3(offset));

        // Should be used when the chebyshev test is weighted more
        //float weight = sqr((dot(L, geometryNormal) + 1.0) * 0.5) + 0.2;
        float weight = dot(L, geometryNormal);
        if (weight < 0.0) continue;

        vec2 momOctCoord = UnitVectorToOctahedron(biasedProbeToPosition);
        vec3 momCoord = GetProbeCoord(gridCell, cascadeIndex, momOctCoord, momRes, momTexelSize, ddgiData.volumeMomentsRes);
        vec2 temp = textureLod(momentsVolume, momCoord, 0).rg;
        float mean = temp.x;
        float mean2 = temp.y;

        float weightCheb = weight;

        float visibilityWeight = 1.0;

        if (biasedDistToProbe > mean) {            
            float variance = abs(mean * mean - mean2);
            float visibility = variance / (variance + sqr(biasedDistToProbe - mean));
            visibilityWeight *= max(0.0, visibility * visibility * visibility);
            totalVisibility += visibilityWeight;
        }
        else {
            totalVisibility += 1.0;
        }

        weight *= max(0.05, visibilityWeight);

        weight = max(0.000001, weight);
        weightCheb = max(0.000001, weightCheb);

        if (weight < 0.2) {
            //weight *= weight * weight / (0.2 * 0.2);
        }

        float trilinearWeight = trilinear.x * trilinear.y * trilinear.z;
        weight *= trilinearWeight;
        weightCheb *= trilinearWeight;

        vec3 irrCoord = GetProbeCoord(gridCell, cascadeIndex, irrOctCoord, irrRes, irrTexelSize, ddgiData.volumeIrradianceRes);
        vec3 irradiance = pow(textureLod(irradianceVolume, irrCoord, 0).rgb, vec3(0.5 * ddgiData.volumeGamma));

        sumIrradiance += weight * irradiance;
        sumIrradianceCheb += weightCheb * irradiance;
        sumWeight += weight;
        sumWeightCheb += weightCheb;
    }

    if (sumWeightCheb == 0.0) return vec4(0.0, 0.0, 0.0, 0.0);
    vec4 irradiance = vec4(mix(sqr(sumIrradianceCheb / sumWeightCheb),
        sqr(sumIrradiance / sumWeight), 1.0), 0.0);

    // Due to the texture format we loose a bit of energy
    irradiance *= 1.0989;

    return irradiance;

}

vec4 GetLocalIrradiance(vec3 P, vec3 V, vec3 N, vec3 geometryNormal) {

    int cascadeIndex = 0;
    while (cascadeIndex < ddgiData.cascadeCount) {

        bool isInside = IsInsideCascade(P, cascadeIndex);
        if (!isInside)
            break;

        cascadeIndex++;
    }

    return GetLocalIrradianceFromCascade(P, V, N, geometryNormal, max(cascadeIndex - 1, 0));

}

vec4 GetLocalIrradianceInterpolated(vec3 P, vec3 V, vec3 N, vec3 geometryNormal) {

    int cascadeIndex = 0;
    while (cascadeIndex < ddgiData.cascadeCount) {

        bool isInside = IsInsideCascade(P, cascadeIndex);
        if (!isInside)
            break;

        cascadeIndex++;
    }

    cascadeIndex = max(cascadeIndex - 1, 0);

    // Shrink AABB to get a proper blend distance
    vec3 aabbMin = ddgiData.volumeCenter.xyz - ddgiData.cascades[cascadeIndex].cellSize.xyz * vec3(ddgiData.volumeProbeCount.xyz - 4) * 0.5;
    vec3 aabbMax = ddgiData.volumeCenter.xyz + ddgiData.cascades[cascadeIndex].cellSize.xyz * vec3(ddgiData.volumeProbeCount.xyz - 4) * 0.5;

    vec3 closestPoint = clamp(P, aabbMin, aabbMax);
    float distanceToAABB = distance(P, closestPoint);

    float minAxialDistance = min3(ddgiData.cascades[cascadeIndex].cellSize.xyz);
    float alpha = min(distanceToAABB / minAxialDistance, 1.0);

    vec4 irradiance = GetLocalIrradianceFromCascade(P, V, N, geometryNormal, cascadeIndex);

    if (alpha > 0.0 && cascadeIndex > 0) {

        vec4 outerIrradiance = GetLocalIrradianceFromCascade(P, V, N, geometryNormal, cascadeIndex - 1);
        //irradiance = mix(irradiance, outerIrradiance, alpha);

    }

    return irradiance;

}

vec4 GetLocalIrradiance(vec3 P, vec3 V, vec3 N) {
    // Use "normal" normal as geometry normal 
    return GetLocalIrradiance(P, V, N, N);
}