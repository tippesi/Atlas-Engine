#include <sharedUniforms.hsh>
#include <shoreInteraction.hsh>

layout(set = 3, binding = 0) uniform sampler2DArray displacementMap;
layout(set = 3, binding = 1) uniform sampler2DArray normalMap;
layout(set = 3, binding = 13) uniform sampler2D perlinNoiseMap;

const float shoreStartScaling = 15.0;
const float shoreOffsetScaling = 5.0;
const float minShoreScaling = 0.3;

const vec4 spectrumScaling = vec4(1.0, 0.5, 0.25, 0.125) / 1.5;

vec3 GetOceanDisplacement(vec3 position, out float perlinScale, 
    out float shoreScale, out vec3 normalShoreWave) {

    vec2 texCoord = position.xz / Uniforms.tiling;

#ifdef TERRAIN
    float waterDepth = shoreStartScaling;

    vec2 terrainTex = (position.xz - vec2(Uniforms.terrainTranslation.xz))
        / Uniforms.terrainSideLength;

    if (terrainTex.x >= 0.0 && terrainTex.y >= 0.0
        && terrainTex.x <= 1.0 && terrainTex.y <= 1.0) {
        waterDepth = position.y - textureLod(terrainHeight, terrainTex, 0.0).r 
            * Uniforms.terrainHeightScale + Uniforms.terrainTranslation.y;
    }

    shoreScale = clamp((waterDepth - shoreOffsetScaling) / 
        (shoreStartScaling - shoreOffsetScaling), minShoreScaling, 1.0);
#else
    shoreScale = 1.0;
#endif
    
    vec3 displacement0 = textureLod(displacementMap, vec3(texCoord, 0.0), 0.0).grb * spectrumScaling.x;
    vec3 displacement1 = textureLod(displacementMap, vec3(texCoord / 3.0 + vec2(0.25), 1.0), 0.0).grb * spectrumScaling.y;
    vec3 displacement2 = textureLod(displacementMap, vec3(texCoord / 6.0 + vec2(0.5), 2.0), 0.0).grb * spectrumScaling.z;
    vec3 displacement3 = textureLod(displacementMap, vec3(texCoord / 9.0 + vec2(0.75), 3.0), 0.0).grb * spectrumScaling.w;
    
    vec3 displacement = displacement0 + displacement1 + displacement2 + displacement3;
    displacement.y *= Uniforms.displacementScale * shoreScale;
    displacement.x *= Uniforms.choppyScale * shoreScale;
    displacement.z *= Uniforms.choppyScale * shoreScale;

    float perlin = textureLod(perlinNoiseMap, texCoord * 0.125 * 0.125, 0.0).r;
    perlinScale = sqr(clamp(perlin, 0.0, 1.0));

    displacement = displacement;

#ifdef TERRAIN
    vec3 dx = vec3(0.1, 0.0, 0.0) + CalculateGerstner(position + vec3(0.1, 0.0, 0.0));
    vec3 dz = vec3(0.0, 0.0, 0.1) + CalculateGerstner(position + vec3(0.0, 0.0, 0.1));
    vec3 centerOffset = CalculateGerstner(position);

    normalShoreWave = normalize(cross(dz - centerOffset, dx - centerOffset));
    displacement += centerOffset;
#endif

    return displacement;

}

void GetOceanGradientAndFold(vec2 texCoord, out float fold, out vec2 gradient) {

    vec4 data0 = texture(normalMap, vec3(texCoord, 0.0)) * spectrumScaling.x;
    vec4 data1 = texture(normalMap, vec3(texCoord / 3.0 + vec2(0.25), 1.0)) * spectrumScaling.y / 3.0;
    vec4 data2 = texture(normalMap, vec3(texCoord / 6.0 + vec2(0.5), 2.0)) * spectrumScaling.z / 6.0;
    vec4 data3 = texture(normalMap, vec3(texCoord / 9.0 + vec2(0.75), 3.0)) * spectrumScaling.w / 9.0;

    float perlin = textureLod(perlinNoiseMap, texCoord * 0.125 * 0.125, 0.0).r;
    float perlinScale = sqr(clamp(perlin, 0.0, 1.0));
    
    fold = data0.a + data1.a + data2.a + data3.a;
    gradient = data0.rg + data1.rg + data2.rg + data3.rg;
    
    //fold *= perlinScale;
    //gradient *= perlinScale;

}